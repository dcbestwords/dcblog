import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,b as i,o as a}from"./app-DDcC_JHc.js";const t="/dcblog/assets/chat-CzlrroLE.jpg",l="/dcblog/assets/websocket-Brl2mt8C.jpg",p="/dcblog/assets/websocket_1-B9hBxxv_.jpg",o="/dcblog/assets/websocket_2-Boa6IEG1.jpg",c={};function r(d,e){return a(),n("div",null,e[0]||(e[0]=[i('<h2 id="一、websocket-基础知识" tabindex="-1"><a class="header-anchor" href="#一、websocket-基础知识"><span>一、WebSocket 基础知识</span></a></h2><p>在讲解 WebSocket 之前，大家首先考虑一下网页中如果出现以下的场景，应该怎么处理？</p><ul><li>弹幕</li><li>在线教育</li><li>股票等金融产品实时报价股</li><li>体育实况更新</li><li>视频会议和聊天</li><li>基于位置的应用</li><li>抢座</li><li>抢购页面的库存</li><li>......</li></ul><p>上述场景有一个共同特点——<strong>实时性</strong></p><p>这种对实时性有要求的页面，会带来一些问题</p><p>比如下面的聊天场景</p><figure><img src="'+t+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>因为我们的 HTTP 协议是 request(请求)-response(响应)模式,<strong>请求必须在前，响应必须在后</strong>，这就导致了服务器无法「主动」的把消息告诉客户端。</p><p>开发者想了很多办法来解决这一问题</p><p>当然终极解决方案自然是 WebSocket，但了解过去的一些做法、参观前辈们经历的痛苦还是有益的。</p><h3 id="_1-短轮询-short-polling" tabindex="-1"><a class="header-anchor" href="#_1-短轮询-short-polling"><span>1. 短轮询 short polling</span></a></h3><p>短轮询是一种 <strong>「话痨式」</strong> 的方式</p><p>客户端每隔一小段时间就向服务器请求一次，询问有没有新消息</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>sequenceDiagram</span></span>
<span class="line"><span>客户端-&gt;&gt;服务器: 有新消息吗？</span></span>
<span class="line"><span>服务器-&gt;&gt;客户端: 没有</span></span>
<span class="line"><span>Note over 客户端,服务器: 一段时间后...</span></span>
<span class="line"><span>客户端-&gt;&gt;服务器: 有新消息吗？</span></span>
<span class="line"><span>服务器-&gt;&gt;客户端: 没有</span></span>
<span class="line"><span>Note over 客户端,服务器: 一段时间后...</span></span>
<span class="line"><span>客户端-&gt;&gt;服务器: 有新消息吗？</span></span>
<span class="line"><span>服务器-&gt;&gt;客户端: 有，user1对你说：你好</span></span>
<span class="line"><span>Note over 客户端,服务器: 一段时间后...</span></span>
<span class="line"><span>客户端-&gt;&gt;服务器: 有新消息吗？</span></span>
<span class="line"><span>服务器-&gt;&gt;客户端: 没</span></span>
<span class="line"><span>Note over 客户端,服务器: 一段时间后...</span></span>
<span class="line"><span>客户端-&gt;&gt;服务器: 有新消息吗？</span></span>
<span class="line"><span>服务器-&gt;&gt;客户端: 没</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现短轮询是非常简单的，客户端只需要设置一个计时器不断发送请求即可</p><p>这种方案的缺陷是非常明显的：</p><ul><li>会产生大量无意义的请求</li><li>会频繁打开关闭连接</li><li>实时性并不高</li></ul><h3 id="_2-长轮询-long-polling" tabindex="-1"><a class="header-anchor" href="#_2-长轮询-long-polling"><span>2. 长轮询 long polling</span></a></h3><p>http 长轮询是服务器收到请求后如果有数据, 立刻响应请求; 如果没有数据就会 hold 一段时间,这段时间内如果有数据立刻响应请求; 如果时间到了还没有数据, 则响应 http 请求;浏览器受到 http 响应后立在发送一个同样 http 请求查询是否有数据;</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>sequenceDiagram</span></span>
<span class="line"><span>客户端-&gt;&gt;+服务器: 有新消息吗？</span></span>
<span class="line"><span>Note right of 服务器: 没有消息hold,不会响应</span></span>
<span class="line"><span>Note right of 服务器: 一段时间之后,有消息了</span></span>
<span class="line"><span>服务器-&gt;&gt;-客户端: user1对你说：在吗?</span></span>
<span class="line"><span>客户端-&gt;&gt;+服务器: 有新消息吗？</span></span>
<span class="line"><span>Note right of 服务器: 没有消息hold,不会响应</span></span>
<span class="line"><span>Note right of 服务器: 一段时间之后,有消息了</span></span>
<span class="line"><span>服务器-&gt;&gt;-客户端: user1对你说：你好,我是韩梅梅</span></span>
<span class="line"><span>客户端-&gt;&gt;服务器: ......</span></span></code></pre></div><p>长轮询有效的解决了「话痨问题」，让每一次请求和响应都是有意义的</p><p>但长轮询仍然存在问题：</p><ul><li><p>客户端长时间收不到响应会导致超时，从而主动断开和服务器的连接</p><blockquote><p>这种情况是可以处理的，在 ajax 请求因为超时而结束时，立即重新发送请求到服务器</p><p>虽然这种做法会让之前的请求变得无意义，但毕竟比短轮询好多了</p></blockquote></li><li><p>由于客户端可能「过早的」请求了服务器，服务器不得不挂起这个请求直到新消息的出现。这会让服务器长时间的占用资源却没什么实际的事情可做。</p></li></ul><h3 id="_3-websocket" tabindex="-1"><a class="header-anchor" href="#_3-websocket"><span>3. WebSocket</span></a></h3><p>WebSocket 是 HTML5 中新协议、新 API，在单个 TCP 连接上提供全双工的通讯模式。</p><p>WebSocket 是独立的基于 TCP 的协议。</p><p>WebSocket 和 HTTP 的关系是，WebSocket 是基于 Http 协议的，或者说借用了 Http 协议来完成一部分握手。WebSocket 的握手被翻译成 HTTP 的升级请求。</p><p>下图描述了 HTTP 与 WebSocket 之间的简单关系</p><figure><img src="`+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>WebSocket 从<strong>协议</strong>上赋予了服务器主动推送消息的能力</p><figure><img src="'+p+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从上图可以看出：</p><ul><li>WebSocket 也是建立在 TCP 协议之上的，利用的是 TCP 全双工通信的能力</li><li>使用 WebSocket，会经历两个阶段：握手阶段、通信阶段</li></ul><p>虽然优于轮询方案，但 WebSocket 仍然是有缺点的：</p><ul><li><p>兼容性</p><p>WebSocket 是 HTML5 新增的内容，因此古董版本的浏览器并不支持</p></li><li><p>维持 TCP 连接需要耗费资源</p><p>对于那些消息量少的场景，维持 TCP 连接确实会造成资源的浪费</p><blockquote><p>为了充分利用 TCP 连接的资源，在使用了 WebSocket 的页面，可以放弃 ajax，都用 WebSocket 进行通信，当然这会带来程序设计上的一些问题，需要权衡。</p></blockquote></li></ul><h3 id="_4-握手" tabindex="-1"><a class="header-anchor" href="#_4-握手"><span>4. 握手</span></a></h3><blockquote><p>WebSocket 协议是一个高扩展性的协议，详细内容会比较复杂，这里仅讲解面试中会问到的握手协议</p></blockquote><p>当客户端需要和服务器使用 WebSocket 进行通信时，首先会使用<strong>HTTP 协议</strong>完成一次特殊的请求-响应，这一次请求-响应就是<strong>WebSocket 握手</strong></p><p>在握手阶段，首先由客户端向服务器发送一个请求，请求地址格式如下：</p><div class="language-undefined" data-highlighter="shiki" data-ext="undefined" data-title="undefined" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 使用HTTP</span></span>
<span class="line"><span>ws://yingside.com/path</span></span>
<span class="line"><span># 使用HTTPS</span></span>
<span class="line"><span>wss://yingside.com/path</span></span></code></pre></div><p>请求头如下：</p><div class="language-undefined" data-highlighter="shiki" data-ext="undefined" data-title="undefined" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Connection: Upgrade /* hey，后续咱们别用HTTP了，升级吧 */</span></span>
<span class="line"><span>Upgrade: websocket /* 我们把后续的协议升级为websocket */</span></span>
<span class="line"><span>Sec-WebSocket-Version: 13 /* websocket协议版本就用13好吗？ */</span></span>
<span class="line"><span>Sec-WebSocket-Key: YWJzZmFkZmFzZmRhYw== /* 密钥：一二三四五 */</span></span></code></pre></div><p>服务器如果同意，就应该响应下面的消息</p><div class="language-undefined" data-highlighter="shiki" data-ext="undefined" data-title="undefined" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>HTTP/1.1 101 Switching Protocols /* 换，马上换协议 */</span></span>
<span class="line"><span>Connection: Upgrade /* 协议升级了 */</span></span>
<span class="line"><span>Upgrade: websocket /* 升级到websocket */</span></span>
<span class="line"><span>Sec-WebSocket-Accept: ZzIzMzQ1Z2V3NDUyMzIzNGVy /* 密钥：上山打老虎 */</span></span></code></pre></div><p><strong>握手完成，后续消息收发不再使用 HTTP，任何一方都可以主动发消息给对方</strong></p><figure><img src="`+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="二、面试题" tabindex="-1"><a class="header-anchor" href="#二、面试题"><span>二、面试题</span></a></h2><ol><li><p>webSocket 协议是什么，能简述一下吗？</p><blockquote><p>参考答案：</p><p>websocket 协议 HTML5 带来的新协议，相对于 http，它是一个持久连接的协议，它利用 http 协议完成握手，然后通过 TCP 连接通道发送消息，使用 websocket 协议可以实现服务器主动推送消息。</p><p>首先，客户端若要发起 websocket 连接，首先必须向服务器发送 http 请求以完成握手，请求行中的 path 需要使用<code>ws:</code>开头的地址，请求头中要分别加入<code>upgrade、connection、Sec-WebSocket-Key、Sec-WebSocket-Version</code>标记</p><p>然后，服务器收到请求后，发现这是一个 websocket 协议的握手请求，于是响应行中包含<code>Switching Protocols</code>，同时响应头中包含<code>upgrade、connection、Sec-WebSocket-Accept</code>标记</p><p>当客户端收到响应后即可完成握手，随后使用建立的 TCP 连接直接发送和接收消息。</p></blockquote></li><li><p>webSocket 与传统的 http 有什么优势</p><blockquote><p>参考答案：</p><p>当页面中需要观察实时数据的变化（比如聊天、k 线图）时，过去我们往往使用两种方式完成</p><p>第一种是短轮询，即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据</p><p>第二种是长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。</p><p>无论是哪一种方式，都暴露了 http 协议的弱点，即响应必须在请求之后发生，服务器是被动的，无法主动推送消息。而让客户端不断的发起请求又白白的占用了资源。</p><p>websocket 的出现就是为了解决这个问题，它利用 http 协议完成握手之后，就可以与服务器建立持久的连接，服务器可以在任何需要的时候，主动推送消息给客户端，这样占用的资源最少，同时实时性也最高。</p></blockquote></li><li><p>前端如何实现即时通讯？</p><blockquote><p>参考答案：</p><ol><li>短轮询。即客户端每隔一段时间就向服务器发送消息，询问有没有新的数据</li><li>长轮询，发起一次请求询问服务器，服务器可以将该请求挂起，等到有新消息时再进行响应。响应后，客户端立即又发起一次请求，重复整个流程。</li><li>websocket，握手完毕后会建立持久性的连接通道，随后服务器可以在任何时候推送新消息给客户端</li></ol></blockquote></li></ol><h2 id="三、常用库" tabindex="-1"><a class="header-anchor" href="#三、常用库"><span>三、常用库</span></a></h2><p><code>socket.io</code>、<code>ws</code></p>',50)]))}const b=s(c,[["render",r],["__file","websocket.html.vue"]]),k=JSON.parse('{"path":"/browser_internet/network/websocket.html","title":"WebSocket","lang":"zh-CN","frontmatter":{"title":"WebSocket","order":4,"category":["前端"],"tag":["通信","WebSocket"],"description":"一、WebSocket 基础知识 在讲解 WebSocket 之前，大家首先考虑一下网页中如果出现以下的场景，应该怎么处理？ 弹幕 在线教育 股票等金融产品实时报价股 体育实况更新 视频会议和聊天 基于位置的应用 抢座 抢购页面的库存 ...... 上述场景有一个共同特点——实时性 这种对实时性有要求的页面，会带来一些问题 比如下面的聊天场景 imgi...","head":[["meta",{"property":"og:url","content":"https://github.com/dcblog/browser_internet/network/websocket.html"}],["meta",{"property":"og:site_name","content":"dcBlog"}],["meta",{"property":"og:title","content":"WebSocket"}],["meta",{"property":"og:description","content":"一、WebSocket 基础知识 在讲解 WebSocket 之前，大家首先考虑一下网页中如果出现以下的场景，应该怎么处理？ 弹幕 在线教育 股票等金融产品实时报价股 体育实况更新 视频会议和聊天 基于位置的应用 抢座 抢购页面的库存 ...... 上述场景有一个共同特点——实时性 这种对实时性有要求的页面，会带来一些问题 比如下面的聊天场景 imgi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-03T11:20:13.000Z"}],["meta",{"property":"article:tag","content":"通信"}],["meta",{"property":"article:tag","content":"WebSocket"}],["meta",{"property":"article:modified_time","content":"2024-12-03T11:20:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"WebSocket\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-03T11:20:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dachao\\",\\"email\\":\\"wyc168hard@163.com\\"}]}"]]},"headers":[{"level":2,"title":"一、WebSocket 基础知识","slug":"一、websocket-基础知识","link":"#一、websocket-基础知识","children":[{"level":3,"title":"1. 短轮询 short polling","slug":"_1-短轮询-short-polling","link":"#_1-短轮询-short-polling","children":[]},{"level":3,"title":"2. 长轮询 long polling","slug":"_2-长轮询-long-polling","link":"#_2-长轮询-long-polling","children":[]},{"level":3,"title":"3. WebSocket","slug":"_3-websocket","link":"#_3-websocket","children":[]},{"level":3,"title":"4. 握手","slug":"_4-握手","link":"#_4-握手","children":[]}]},{"level":2,"title":"二、面试题","slug":"二、面试题","link":"#二、面试题","children":[]},{"level":2,"title":"三、常用库","slug":"三、常用库","link":"#三、常用库","children":[]}],"git":{"createdTime":1710854012000,"updatedTime":1733224813000,"contributors":[{"name":"dachao","email":"1114686398@qq.com","commits":3}]},"readingTime":{"minutes":7.35,"words":2205},"filePathRelative":"browser_internet/network/websocket.md","localizedDate":"2024年3月19日","excerpt":"<h2>一、WebSocket 基础知识</h2>\\n<p>在讲解 WebSocket 之前，大家首先考虑一下网页中如果出现以下的场景，应该怎么处理？</p>\\n<ul>\\n<li>弹幕</li>\\n<li>在线教育</li>\\n<li>股票等金融产品实时报价股</li>\\n<li>体育实况更新</li>\\n<li>视频会议和聊天</li>\\n<li>基于位置的应用</li>\\n<li>抢座</li>\\n<li>抢购页面的库存</li>\\n<li>......</li>\\n</ul>","autoDesc":true}');export{b as comp,k as data};

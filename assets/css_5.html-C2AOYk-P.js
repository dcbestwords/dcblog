import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as t,o as l}from"./app-DDcC_JHc.js";const n="/dcblog/assets/16544341635974-DGIbzthA.jpg",e="/dcblog/assets/buju-BtKoVxjH.png",o="/dcblog/assets/shijue-G0oF_aCM.png",r={};function p(h,i){return l(),a("div",null,i[0]||(i[0]=[t('<h2 id="一、animation" tabindex="-1"><a class="header-anchor" href="#一、animation"><span>一、Animation</span></a></h2><blockquote><p><strong>过渡和动画无法对所有的 CSS 属性产生影响，能够产生影响的只有数值类属性</strong>，例如：颜色、宽高、字体大小等等</p></blockquote><h3 id="_1-过渡-transition" tabindex="-1"><a class="header-anchor" href="#_1-过渡-transition"><span>1. 过渡（transition）</span></a></h3><p>通过过渡可以指定一个属性发生变化时的切换方式，创建一些非常好的效果，提升用户的体验。</p><ul><li><code>transition-property: height , width;</code><ul><li>指定要执行过渡的<strong>属性</strong>，多个属性间使用,隔开，如果所有属性都需要过渡，则使用 all 关键字</li><li>大部分属性都支持过渡效果，注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡</li></ul></li><li><code>transition-duration: 100ms, 2s;</code><ul><li>指定过渡效果的<strong>持续时间</strong>, 时间单位：s 和 ms</li></ul></li><li><code>transition-timing-function: steps(2, start);</code><ul><li>过渡的时序函数,指定<strong>过渡执行的方式</strong></li><li>可选值：</li><li><code>ease</code> 默认值，慢速开始，先加速，再减速</li><li><code>linear</code> 匀速运动</li><li><code>ease-in</code> 加速运动</li><li><code>ease-out</code> 减速运动</li><li><code>ease-in-out</code> 先加速 后减速</li><li><code>cubic-bezier()</code> 来指定时序函数（<a href="https://cubic-bezier.com" target="_blank" rel="noopener noreferrer">时序函数编辑</a>）</li><li><code>steps()</code> 分步执行过渡效果,可以设置第二个值来表明在时间开始还是结束来执行过渡</li></ul></li><li><code>transition-delay: 2s;</code><ul><li>过渡效果的<strong>延迟</strong>，等待一段时间后在执行过渡</li></ul></li><li><code>transition:2s margin-left 1s cubic-bezier(.24,.95,.82,-0.88);</code> <strong style="color:red;">简写属性</strong><ul><li>可以同时设置过渡相关的所有属性，只有一个要求，如果要写延迟，则两个时间中第一个是持续时间，第二个是延迟。</li></ul></li></ul><blockquote><p>在 JS 中，可以监听元素的<code>transitionstart</code>和<code>transitionend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</p></blockquote><h3 id="_2-动画" tabindex="-1"><a class="header-anchor" href="#_2-动画"><span>2. 动画</span></a></h3><p>动画和过渡类似，都可以实现一些动态的效果，不同的是过渡需要在某个属性发生变化时才会触发，而动画可以自动触发动态效果。要想设置动画效果，必须先要设置一个关键帧，关键帧设置了动画执行的每一个步骤。</p><figure><img src="'+n+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="关键帧的设置" tabindex="-1"><a class="header-anchor" href="#关键帧的设置"><span>关键帧的设置</span></a></h4><div class="language-css" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@keyframes</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /* from表示动画的开始位置 也可以使用 0% */</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  from {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    margin-left: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    background-color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">orange</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  /* to动画的结束位置 也可以使用100%*/</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  to {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    background-color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">red</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    margin-left: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">700</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">px</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><h4 id="动画的设置" tabindex="-1"><a class="header-anchor" href="#动画的设置"><span>动画的设置</span></a></h4><ul><li><code>animation-name: test;</code> 要对当前元素生效的关键帧的<strong>名字</strong></li><li><code>animation-duration: 4s;</code> 动画的<strong>执行时间</strong></li><li><code> animation-delay: 2s;</code> 动画的<strong>延时</strong></li><li><code>animation-iteration-count: 1;</code> 动画执行的<strong>次数</strong> ( infinite 无限执行)</li><li><code> animation-direction: alternate-reverse;</code> 指定动画运行的<strong>方向</strong><ul><li>normal 默认值 从 from 向 to 运行 每次都是这样</li><li>reverse 从 to 向 from 运行 每次都是这样</li><li>alternate 从 from 向 to 运行 重复执行动画时反向执行</li><li>alternate-reverse 从 to 向 from 运行 重复执行动画时反向执行</li></ul></li><li><code>animation-play-state: paused;</code> 设置动画的<strong>执行状态</strong></li><li><code>animation-fill-mode: both;</code> 动画的<strong>填充模式</strong><ul><li>none 默认值 动画执行完毕元素回到原来位置</li><li>forwards 动画执行完毕元素会停止在动画结束的位置</li><li>backwards 动画延时等待时，元素就会处于开始位置</li><li>both 结合了 forwards 和 backwards</li></ul></li><li><code>animation: ball .5s forwards linear infinite alternate;</code></li></ul><blockquote><p>在 JS 中，可以监听元素的<code>animationstart</code>和<code>animationnend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</p></blockquote><hr><h2 id="二、移动端开发" tabindex="-1"><a class="header-anchor" href="#二、移动端开发"><span>二、移动端开发</span></a></h2><h3 id="_1-像素" tabindex="-1"><a class="header-anchor" href="#_1-像素"><span>1. 像素</span></a></h3><p>屏幕是由一个个发光的小点构成，这一个个的小点就是像素。我们常说的分辨率：1920 x 1080 说的就是屏幕中小点的数量。在前端开发中像素要分成两种情况讨论：<strong>CSS 像素</strong> 和 <strong>物理像素</strong>，上述所说的小点就属于物理像素，而 css 像素指的是编写网页时我们所用的像素。浏览器在显示网页时，需要将 CSS 像素转换为物理像素然后再进行呈现，一个 css 像素最终由几个物理像素显示由浏览器决定：默认情况下在 pc 端，一个 css 像素 = 一个物理像素。</p><h3 id="_2-视口-viewport" tabindex="-1"><a class="header-anchor" href="#_2-视口-viewport"><span>2. 视口（viewport）</span></a></h3><h4 id="视口分类" tabindex="-1"><a class="header-anchor" href="#视口分类"><span>视口分类</span></a></h4><blockquote><p>视口就是屏幕中用来显示网页的区域，在移动端，我们将视口分成三种情况：</p><ul><li>布局视口（layout viewport） <ul><li>作为开发人员，当我们在 pc 端进行布局时会相对于默认的 980px（实际上不同的浏览器默认值可能不同）进行布局，这个默认 980px 的视口称之为布局视口</li><li><img src="`+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>视觉视口（visual layout） <ul><li>如果默认情况下，我们按照 980px 显示内容，那么右侧有一部分区域 就会无法显示，所以手机端浏览器会默认对页面进行<strong>缩放</strong>以显示到用 户的可见区域中</li><li>那么显示在<strong>可见区域</strong>的这个视口，就是<strong>视觉视口</strong>（visual viewport）</li><li><img src="'+o+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li></ul></li><li>理想视口（ideal layout） <ul><li>我们通过对 layout viewport 进行宽度和缩放的设置，以满足正常在一个移动端窗口的布局；<strong>就是布局视口和视觉视口的大小相同</strong></li></ul></li><li><a href="https://blog.csdn.net/m0_51636525/article/details/124468206" target="_blank" rel="noopener noreferrer">点击原博客地址查看全文</a></li></ul></blockquote><h3 id="_3-像素比" tabindex="-1"><a class="header-anchor" href="#_3-像素比"><span>3. 像素比</span></a></h3><p>我们可以通过查看视口的大小，来观察 CSS 像素和物理像素的比值。</p><ul><li>默认情况下： 视口宽度 1920px（CSS 像素）、1920px（物理像素）， 此时，css 像素和物理像素的比是 1:1</li><li>放大两倍的情况：视口宽度 960px（CSS 像素）、1920px（物理像素）， 此时，css 像素和物理像素的比是 1:2</li><li>我们可以通过改变视口的大小，来改变 CSS 像素和物理像素的比值</li></ul><p>在不同的屏幕，单位像素的大小是不同的，像素越小屏幕会越清晰。智能手机的像素点远远小于计算机的像素点， 默认情况下，移动端的网页都会将视口设置为 980 像素（<strong>css 像素</strong> ），以确保 pc 端网页可以在移动端正常访问，但是如果网页的宽度超过了 980，移动端的浏览器会自动对网页缩放以完整显示网页，所以基本大部分的 pc 端网站都可以在移动端中正常浏览，但是往往都不会有一个好的体验，为了解决这个问题，大部分网站都会专门为移动端设计网页。</p><p>每一款移动设备设计时，都会有一个最佳的像素比， 一般我们只需要将像素比设置为该值即可得到一个最佳效果，将像素比设置为最佳像素比的视口大小我们称其为完美视口（即上面所说的理想视口）。</p><p><strong style="color:red;"> 将网页的视口设置为完美视口</strong></p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></p><ul><li>结论：以后再写移动端的页面，就把上边这个玩意先写上</li><li>当然一般情况下我们使用 IDE 自动生成的代码中会自动包含此部分</li><li>这行代码起到了两个作用，直接作用是使得布局视口和视觉视口的大小相同；间接作用是使得网页达到最佳的显示效果</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>实际上我们不用关心设备的物理像素为多少，当我们获取 device-width 时，获取的是 css 像素表示的设备宽度，而不是真实的物理像素，这个像素值就是根据最佳像素比进行设置的。</p></div><h3 id="_4-移动端单位" tabindex="-1"><a class="header-anchor" href="#_4-移动端单位"><span>4. 移动端单位</span></a></h3><p>由于不同设备视口和像素比不同，所以同样的 375 个像素在不同的设备下意义是不一样的，比如在 iphone6 中 375 就是全屏，而到了 plus 中 375 就会缺一块，所以在移动端开发时，就不能再使用 px 来进行布局了。</p><p><strong style="color:green;">vw 表示的是视口的宽度</strong></p><ul><li>100vw = 一个视口的宽度</li><li>1vw = 1%视口宽度</li><li>vw 这个单位永远相当于视口宽度进行计算</li><li>创建一个 48px x 35px 大小的元素（ <mark>显示页面与设计图的一个对应关系</mark> ） <ul><li>100vw = 750px(设计图的像素) 0.1333333333333333vw = 1px</li><li>6.4vw = 48px(设计图像素)</li><li>4.667vw = 35px</li></ul></li></ul><p><strong style="color:green;">rem 表示的单个字体的大小</strong></p><ul><li><p>1 rem = 1 html 的字体大小</p></li><li><p>在 html 标签中设置字体大小<code>font-size: 5.3333vw;</code>（40px）</p></li><li><p>其他属性设置时则参照字体大小进行设置：像素值/40 rem</p></li></ul><h2 id="三、响应式布局" tabindex="-1"><a class="header-anchor" href="#三、响应式布局"><span>三、响应式布局</span></a></h2><p>网页可以根据不通的设备或窗口大小呈现出不同的效果，使用响应式布局，可以使一个网页适用于所有设备。 响应布局的关键就是<strong>媒体查询</strong>，通过媒体查询，可以为不同的设备，或设备不同的状态来分别设置样式。</p><p>语法： <code>@media 查询规则{}</code></p><ul><li><p>媒体类型</p><ul><li>all 所有设备</li><li>print 打印设备</li><li>screen 带屏幕的设备</li><li>speech 屏幕阅读器</li><li>可以使用,连接多个媒体类型，这样它们之间就是一个或的关系</li></ul></li><li><p>媒体特性</p><ul><li><p>width 视口的宽度、 height 视口的高度</p></li><li><p>min-width 视口的最小宽度（视口大于指定宽度时生效）</p></li><li><p>max-width 视口的最大宽度（视口小于指定宽度时生效）</p></li><li><p>样式切换的分界点，我们称其为断点，也就是网页的样式会在这个点时发生变化</p><p>一般比较常用的断点</p><ul><li>小于 768 超小屏幕 max-width=768px</li><li>大于 768 小屏幕 min-width=768px</li><li>大于 992 中型屏幕 min-width=992px</li><li>大于 1200 大屏幕 min-width=1200px</li></ul></li></ul></li></ul><div class="language-css" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">@media</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> only</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;"> screen</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (min-width: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">500</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">px</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (max-width: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">700</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">px</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  body</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    background-color: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">#</span><span style="--shiki-light:#0184BC;--shiki-dark:#D19A66;">bfa</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre></div><p>​</p>`,42)]))}const k=s(r,[["render",p],["__file","css_5.html.vue"]]),g=JSON.parse('{"path":"/basic_language/CSS/css_5.html","title":"过渡、动画与响应式","lang":"zh-CN","frontmatter":{"title":"过渡、动画与响应式","icon":"shuffle fas","order":5,"category":["前端"],"tag":["CSS","移动端适配","Animation","响应式"],"description":"一、Animation 过渡和动画无法对所有的 CSS 属性产生影响，能够产生影响的只有数值类属性，例如：颜色、宽高、字体大小等等 1. 过渡（transition） 通过过渡可以指定一个属性发生变化时的切换方式，创建一些非常好的效果，提升用户的体验。 transition-property: height , width; 指定要执行过渡的属性，多个...","head":[["meta",{"property":"og:url","content":"https://github.com/dcblog/basic_language/CSS/css_5.html"}],["meta",{"property":"og:site_name","content":"dcBlog"}],["meta",{"property":"og:title","content":"过渡、动画与响应式"}],["meta",{"property":"og:description","content":"一、Animation 过渡和动画无法对所有的 CSS 属性产生影响，能够产生影响的只有数值类属性，例如：颜色、宽高、字体大小等等 1. 过渡（transition） 通过过渡可以指定一个属性发生变化时的切换方式，创建一些非常好的效果，提升用户的体验。 transition-property: height , width; 指定要执行过渡的属性，多个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-03T10:02:36.000Z"}],["meta",{"property":"article:tag","content":"CSS"}],["meta",{"property":"article:tag","content":"移动端适配"}],["meta",{"property":"article:tag","content":"Animation"}],["meta",{"property":"article:tag","content":"响应式"}],["meta",{"property":"article:modified_time","content":"2024-12-03T10:02:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"过渡、动画与响应式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-03T10:02:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Dachao\\",\\"email\\":\\"wyc168hard@163.com\\"}]}"]]},"headers":[{"level":2,"title":"一、Animation","slug":"一、animation","link":"#一、animation","children":[{"level":3,"title":"1. 过渡（transition）","slug":"_1-过渡-transition","link":"#_1-过渡-transition","children":[]},{"level":3,"title":"2. 动画","slug":"_2-动画","link":"#_2-动画","children":[]}]},{"level":2,"title":"二、移动端开发","slug":"二、移动端开发","link":"#二、移动端开发","children":[{"level":3,"title":"1. 像素","slug":"_1-像素","link":"#_1-像素","children":[]},{"level":3,"title":"2. 视口（viewport）","slug":"_2-视口-viewport","link":"#_2-视口-viewport","children":[]},{"level":3,"title":"3. 像素比","slug":"_3-像素比","link":"#_3-像素比","children":[]},{"level":3,"title":"4. 移动端单位","slug":"_4-移动端单位","link":"#_4-移动端单位","children":[]}]},{"level":2,"title":"三、响应式布局","slug":"三、响应式布局","link":"#三、响应式布局","children":[]}],"git":{"createdTime":1710854012000,"updatedTime":1733220156000,"contributors":[{"name":"dachao","email":"1114686398@qq.com","commits":3}]},"readingTime":{"minutes":8.23,"words":2470},"filePathRelative":"basic_language/CSS/css_5.md","localizedDate":"2024年3月19日","excerpt":"<h2>一、Animation</h2>\\n<blockquote>\\n<p><strong>过渡和动画无法对所有的 CSS 属性产生影响，能够产生影响的只有数值类属性</strong>，例如：颜色、宽高、字体大小等等</p>\\n</blockquote>","autoDesc":true}');export{k as comp,g as data};
